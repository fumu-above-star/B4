//192.168.29.13: icx -O3 : 10分55秒
//192.168.29.13: icc -O3 : 11分54秒
//192.168.29.13: gcc -O  : 12分49秒
//192.168.29.13: gcc -O3 : 13分46秒  ※ gcc -O3 だと遅くなるので使わないこと
//c40.ns3.jp   : icx -O3 : 14分39秒
//c40.ns3.jp   : icc -O3 : 15分25秒
//c40.ns3.jp   : gcc -O  : 16分21秒
//--------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int b[4]={0, 0b0000000000000000, 0b0000000000000000, 0b0000000000000000};
int pa_orig[16] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};
int pa[16];

int bitboard[16][7]={
  //  0 / 1,2  4,8  5,10
  {0b1001111111111111, 0b1111011101111111, 0b1111101111011111, 0, 0, 0, 0},
  //  1 / 0,2  2,3  5,9  6,11
  {0b0101111111111111, 0b1100111111111111, 0b1111101110111111, 0b1111110111101111, 0, 0, 0},
  //  2 / 0,1  1,3  5,8  6,10
  {0b0011111111111111, 0b1010111111111111, 0b1111101101111111, 0b1111110111011111, 0, 0, 0},
  //  3 / 1,2  6,9  7,11
  {0b1001111111111111, 0b1111110110111111, 0b1111111011101111, 0, 0, 0, 0},
  //  4 / 0,8  5,6  8,12  9,14
  {0b0111111101111111, 0b1111100111111111, 0b1111111101110111, 0b1111111110111101, 0, 0, 0},
  //  5 / 0,10  1,9  2,8  4,6  6,7  9,13  10,15
  {0b0111111111011111, 0b1011111110111111, 0b1101111101111111, 0b1111010111111111, 0b1111110011111111, 0b1111111110111011, 0b1111111111011110},
  //  6 / 1,11  2,10  3,9  4,5  5,7  9,12  10,14
  {0b1011111111101111, 0b1101111111011111, 0b1110111110111111, 0b1111001111111111, 0b1111101011111111, 0b1111111110110111, 0b1111111111011101},
  //  7 / 3,11  5,6  10,13  11,15
  {0b1110111111101111, 0b1111100111111111, 0b1111111111011011, 0b1111111111101110, 0, 0, 0},
  //  8 / 0,4  2,5  4,12  9,10
  {0b0111011111111111, 0b1101101111111111, 0b1111011111110111, 0b1111111110011111, 0, 0, 0},
  //  9 / 1,5  3,6  4,14  5,13  6,12  8,10  10,11
  {0b1011101111111111, 0b1110110111111111, 0b1111011111111101, 0b1111101111111011, 0b1111110111110111, 0b1111111101011111, 0b1111111111001111},
  // 10 / 0,5  2,6  5,15  6,14  7,13  8,9  9,11
  {0b0111101111111111, 0b1101110111111111, 0b1111101111111110, 0b1111110111111101, 0b1111111011111011, 0b1111111100111111, 0b1111111110101111},
  // 11 / 1,6  3,7  7,15  9,10
  {0b1011110111111111, 0b1110111011111111, 0b1111111011111110, 0b1111111110011111, 0, 0, 0},
  // 12 / 4,8  6,9  13,14
  {0b1111011101111111, 0b1111110110111111, 0b1111111111111001, 0, 0, 0, 0},
  // 13 / 5,9  7,10  12,14  14,15
  {0b1111101110111111, 0b1111111011011111, 0b1111111111110101, 0b1111111111111100, 0, 0, 0},
  // 14 / 4,9  6,10  12,13  13,15
  {0b1111011110111111, 0b1111110111011111, 0b1111111111110011, 0b1111111111111010, 0, 0, 0},
  // 15 / 5,10  7,11  13,14
  {0b1111101111011111, 0b1111111011101111, 0b1111111111111001, 0, 0, 0, 0}
};

int move(int te, int depth, int pa_cnt) // 勝ちの手番を返す。自分以外のどちらかが勝つときは -1、ドローなら 0 を返す。
{
  int i, j, p, ret, max = -2;
  int backup;
  int db_depth;

  for(i = 0; i < pa_cnt; i++){
    p = pa[i];
    if( (b[te] | bitboard[p][0]) == 0b1111111111111111 ) return te;
    if( (b[te] | bitboard[p][1]) == 0b1111111111111111 ) return te;
    if( (b[te] | bitboard[p][2]) == 0b1111111111111111 ) return te;
    if( bitboard[p][3] == 0 ) continue;
    if( (b[te] | bitboard[p][3]) == 0b1111111111111111 ) return te;
    if( bitboard[p][4] == 0 ) continue;
    if( (b[te] | bitboard[p][4]) == 0b1111111111111111 ) return te;
    if( (b[te] | bitboard[p][5]) == 0b1111111111111111 ) return te;
    if( (b[te] | bitboard[p][6]) == 0b1111111111111111 ) return te;
  }
  if( depth >= 13) return 0;// 
  if( pa_cnt == 1 ) return 0;  //末端で勝てなかったのでドロー

  for(i = 0; i < pa_cnt; i++){
    p = pa[i];
    if( depth <= 3 ) {
      printf("depth=%d(te=%d) p=%d ", depth, te, p);
      fflush(stdout);
    }
    backup = b[te];
    b[te] |= (1 << (15 - p));
    for(int j = i; j < pa_cnt - 1; j++) pa[j] = pa[j+1]; // 残指し手を詰める
    ret = move((te % 3) + 1, depth + 1, pa_cnt - 1);
    b[te] = backup;
    for(int j = pa_cnt - 3; j >= i; j--) pa[j+1] = pa[j]; // 残指し手を戻す
    pa[i] = p;
    if( depth <= 3 ) printf("ret=%d\n", ret);
    if( ret == te ) return te; // 自分の勝ちならその手でよい
    if( max == 0 ) continue;//その局面でteの打てる手に勝ちがなく引き分けがあればmaxは0(引き分け)となる
    if( ret == 0 ) { max = 0; continue; }//引き分け
    if( max == -1 ) continue;//その局面でte以外のどちらか二人が勝つことがteにとって最善の状態であればmaxは-1 //ret == 0か ret == teになる手を探す
    if( max == -2 ) { max = ret; continue; }//勝でも引き分けでもなければte以外の買ったプレイヤーの番号をmaxに代入
    if( ret != max ) { max = -1; continue; }//maxが0でも-1でも-2でもなく、retがteでも0でもない場合その手はte以外のどちらか二人が勝つ-1(不定の負け)
  }
  return max;
}

int search()
{
  int i, p, x, pa_cnt;

  // 残指し手配列 pa[] の構築
  for(i = pa_cnt = 0; i< 16; i++){
    p = pa_orig[i];
    x = 1 << (15 - p);
    if( ((b[1] & x)==0) && ((b[2] & x)==0) && ((b[3] & x)==0) ) pa[pa_cnt++] = p;
  }
  return move(2, 2, pa_cnt);
}

int main(int argc, char *argv[])
{
  int ret;

  
  b[1] = 0b0000010000000000; // 5 の場所
  printf("*** te=1 p=5\n");
  ret = search();
  printf("ret = %d\n", ret);
  
  
  b[1] = 0b0100000000000000; // 1 の場所
  printf("*** te=1 p=1\n");
  ret = search();
  printf("ret = %d\n", ret);
  
  
  b[1] = 0b1000000000000000; // 0 の場所
  printf("*** te=1 p=0\n");
  ret = search();
  printf("ret = %d\n", ret);
  

  return 0;
}
